# 一、知识点

1.  有没有学过其他语言？和其他语言的区别？

2.  python2和python3区别？

    1.  解释器默认编码
    2.  字符串、字节
    3.  经典类和新式类
    4.  yield from
    5.  字典的 items、values、keys获取的是迭代器，py2中是list
    6.  还有简单的：print，input，range，xrange、int、long

3.  pass作用？

    python中的语法是通过缩紧方式体现的

4.  *args和**kwargs作用？

5.  列举数据类型常用的方法

6.  集合的运算

    ```python
    v1 = {1, 2}
    v2 = {1, 3}
    # 求交集
    v3 = v1 & v2
    # 求并集
    v4 = v1 ｜ v2
    # 求差集
    v5 = v1 - v2
    ```

7.  ((1),(2),(3))和(1,2,3)的区别？

8.  大文件操作？

9.  常用的内置函数？

    ```python
    len、range、help、数据类型转换、进制转换
    ```

10.  高级内置函数？(重要)

     ```python
     map/reduce/filter/zip
     # 函数的功能
     # 例子
     ```

11.  函数参数是可变类型

     ```python
     def func(a, b=[]):
         pass
     ```

12.  什么是闭包？

     ```python
     # 内部函数调用外部函数存储的数据
     def func(arg):
         v = 123
         def inner():
             print(v)
         return inner
     
     data = func()
     data()
     ```

13.  装饰器和带参数的装饰器？

     ```python
     # 手写装饰器
     ```

14.  列表生成式？

     ```python
     v = [lambda x: x + 10 for x in range(10)]
     v[3]()			# 19
     ```

15.  迭代器和生成器？

     -   迭代器：**从前到后逐一取值，只能向前无法倒退**，可以使用内部的 `__next__`方法取值。

     ```python
     v1 = iter([1,2,3,4,5,6])
     v1.__next__()
     or next内置函数本质也是调用__next__()方法
     next(v1)
     ```

     -   生成器：可以防止在内存中一次创建太多数据，而使用生成器让它在使用的过程中再逐步创建。一个函数内部含有yield关键字，则此函数就是一个生成器函数。

     ```python
     # 生成器函数
     def func():
         yield 1
         yield 2
     # 生成器
     v = func()
     ```

16.  函数传递参数传递的是什么？

     -   python中参数传递的是引用

     ```python
     a = [1, 2, 3]				# 引用计数器：1
     def func(arg):
         print(id(arg))
         print(id(a))
     func(a)						# 引用计数器：2
     # 4402436368
     # 4402436368
     ```

17.   找文件夹下的所有文件？

     ```python
     os.walk
     ```

18.   re中的match和search的区别？

     -   match是从头匹配
     -   search是遍历整个字符串

19.  什么是贪婪匹配？

     -   在正则匹配中，贪婪匹配是尽可能多的取匹配。可以通过在正则表达式后加 ？来控制

20.  html文件，找到某个标签，如a标签中的href的值

     ```python
     <a href="www.baidu.com"></a>
     ```

21.  如何获取用户通过脚本传递的参数？

     ```python
     import sys
     # 是个list
     sys.argv
     ```

22.  @staticmethod和@classmethod的区别？

     ```python
     # 从传参和执行角度
     @staticmethod			# 通过类直接调用，不需要参数
     @classmethod			# 有一个 cls 参数
     ```

23.  类变量

     ```python
     class Base:
         x = 1
     class Foo(Base):
         pass
     class Bar(Base):
         pass
     # 参考小绿本
     ```

24.  super作用？

     -   根据类的继承关系(mro)，向上寻找方法或属性

     ```python
     class Base(object):
         def func(self):
             print('base.func')
             super().func()
     
     class Bar(object):
         def func(self):
             print('bar.func')
     
     class Foo(Base, Bar):
         pass
     
     obj = Foo()
     obj.func()					# 会执行 Bar 里的方法 
     ```

25.  魔法方法（双下方法）

     ```python
     __new__
     1. 返回的是什么？	返回一个没有初始化的对象(内部为空的对象)
     2. 单例模式
     __call__
     __enter__
     __exit__
     1. 上下文管理
     # f 为类的一个对象
     with 类() as f:
         pass
     __getitem__
     __setitem__
     __delitem__
     1. 对象通过索引取值，django/flask中的 session
     # 对象的相加
     __add__
     ```

     -   `__new__`

     ```python
     class Foo(object):
         def __init__(self, name):
             self.name = name
             
         def __new__(self, cls):
             # 创建一个空的 Foo 类的对象
             return object.__new__(cls)
     obj = Foo('echo')
     ```

     ```python
     # 单例模式（需要加锁）
     class Singleton(object):
         __instance = None
     
         def __new__(cls, *args, **kwargs):
             from threading import Lock
             with Lock():
                 if not cls.__instance:
                     cls.__instance = object.__new__(cls)
                 return cls.__instance
     
         def __init__(self, name):
             self.name = name
     
     obj1 = Singleton('henry')
     obj2 = Singleton('echo')
     print(id(obj1), id(obj2))
     ```

     -   `__add__`

     ```python
     class Foo(object):
         # self == obj1, other == obj2
     	def __add__(self, other):
             return 666
               
     obj1 = Foo()
     obj2 = Foo()
     res = obj1 + obj2
     ```

26.  什么是元类？

     -   python中类都是通过 type 创建的

     ```python
     class Foo(object):
         pass
     # 等价于
     Foo = type("Foo", (object,), {})
     # 通过metaclass 可以指定类由谁来创建
     class Foo(object, metaclass='xxx'):
         pass
     # 元类就是用于指定当前类是由谁来创建的
     ```

27.  c/s和b/s架构？

28.  简述TCP三次握手和四次挥手？(越详细越好)

29.  OSI七层模型？

30.  TCP和UDP的区别？

     -   tcp：面向连接的，流式传输
     -   udp：无连接，数据报的传输，数据块的传输

31.  什么是粘包？

     -   由于两端通信时，会经过计算机的缓存区，并且传输数据时是**流式无边界**，导致粘包
     -   例如：A和B通信，A发送了2个数据包，B在接收时无法区分数据的边界，所以可能会获取错误。
     -   为了解决此显现，我们通过struct模块自定义数据内容： **头信息|数据。** 

32.  socket代码客户端和服务端连接？

     ```python
     # server 端
     from socket import socket
     
     sk = socket()
     sk.bind(("127.0.0.1", 8000))
     sk.listen()
     conn, addr = sk.accept()
     msg = conn.recv(1024)
     print(msg)
     conn.send(msg.decode('utf8').upper().encode('utf8'))
     conn.close()
     sk.close()
     
     
     # client 端
     from socket import socket
     sk = socket()
     sk.connect(("127.0.0.1", 8000))
     sk.send(b'hello')
     msg = sk.recv(1024)
     print(msg)
     sk.close()
     ```

33.  断点续传实现思路？

     1.  当前下载文件的字节数，发送给server 端
     2.  server 使用 seek方法找到文件位置，继续传输

34.  进程、线程、协程的区别？

     1.  进程，计算机中资源分配的最小单位，os控制切换开销较大，数据隔离
     2.  线程，计算机中cpu调度的最小单位，os控制切换开销较小，数据不安全
     3.  协程又称为微线程与进程线程不同，协程是人为创建出来，本质是通过一个线程实现并发操作。在I/O操作将提升程序效率
     4.  一个进程中可以有多个线程、一个线程中可以有多个协程。都可以完成并发操作，特殊协程只有遇到IO切换才有意义，否则效率反而会降低。

35.  GIL锁的作用？

     1.  GIL锁就是全局解释器锁
         -   其他编程语言中没有 GIL 锁，这是Cpython特有。
     2.  保证一个进程中，同一时刻只有一个线程被CPU调度
     3.  可以在一定程度上，保证数据安全
         -   list、dict在调用内部方法时，是线程安全的
         -   v = []    v.append(100)
     4.  其他操作，如果想要线程安全，需要通过Lock或RLock实现
     5.  计算密集型用多进程、IO密集型用多线程

36.  IO多路复用？

     -   **监听多个IO对象是否发生变化（创建连接、收发数据）**
         1.  select：**最多监听1024个IO对象**；轮询的方式检查。
         2.  poll：不限制IO对象的个数；轮询的方式检查。
         3.  epoll：不限制IO对象的个数；**回调的方式**进行检查。 

     ```python
     # 示例，同时监听多个端口
     # 不能同时监听
     s1 = socket.socket()
     s1.bind(...8001)
     s1.listen(5)
     conn,addr = s1.accept()
     
     s2 = socket.socket()
     s2.bind(...8002)
     s2.listen(5)
     conn, addr = s2.accept()
     
     ---------------------------------
     # 可以同时监听，一直占用CPU效率很低
     s1 = socket.socket()
     s1.bind(...8001)
     s1.setBlocking(False)
     s1.listen(5)
     conn,addr = s1.accept()
     
     s2 = socket.socket()
     s2.bind(...8002)
     s2.setBlocking(False)
     s2.listen(5)
     conn,addr = s2.accept()
     
     ---------------------------------
     import select
     import socket
     
     s1 = socket.socket()
     s1.bind(('127.0.0.1', 8001))
     s1.listen(5)
     
     s2 = socket.socket()
     s2.bind(('127.0.0.1', 8002))
     s2.listen(5)
     
     while True:
         # rlist：如果有socket连接，会得到一个socket列表
         rlist, wlist, xlist = select.select([s1, s2], [], [], 0.05)
         for s in rlist:
             conn, addr = s.accept()
     ```

37.  数据库引擎

     1.  myisam：不支持事务；速度快且支持全文索引
     2.  innodb：支持事务；支持表锁和行锁

38.  事务的特性

     -   原子性、一致性、隔离性、持久性

39.  SQL练习题

40.  inner join 和 left join区别？

     ```python
     # 部门表 dept
     title
     IT 
     销售
     运营
     # 用户表 user
     id name dept_id
     1 henry 1
     # 只有 1 条数据
     select user.id, dept.title from user left join dept on user.dept_id = dept.id
     # 会有 3 条数据
     select user.id, dept.title from dept left join dept on user.dept_id = dept.id
     # 只有 1 条数据
     select user.id, dept.title from user inner join dept on user.dept_id = dept.id
     ```

41.  char 和 varchar 的区别？

     -   char是定长的
     -   varchar是变长的
     -   varchar(50) 中的**50代表字符的长度**

42.  笛卡尔积

     ```sql
     select * from a, b
     ```

43.  联合索引如何命中索引？

     1.  最左前缀原则

44.  数据库的备份

     ```python
     # 只导出表结构
     mysqldump -uroot -proot -b 数据库 > 数据库.sql
     # 导出表结构 + 数据
     mysqldump -uroot -proot 数据库 > 数据库.sql
     ```

45.  数据库优化方案

     1.  数据库的**读写分离**

     2.  做缓存(redis、memcached)

     3.  分库分表，分库：功能不同业务进行分库，分表：历史表和当前表(流水账单)

     4.  使用索引并且命中索引

     5.  设计表结构时，把**定长数据放前面**，变长放后面

     6.  有些数据放在内存中，不做连表查询(choices)

         -   基于数据库：性别表、用户表

         ```python
         # 性别表
         id title
         1 男
         2 女
         # 用户表
         id name gender_id
         1 henry 1
         # 代码中
         ((1, '男'), (2, '女'))
         ```

46.  无法命中索引的情况？

     1.  使用模糊匹配，like
     2.  使用函数、计算等
     3.  or 
     4.  类型不一致、!=、>、order by
     5.  联合索引：没有遵循最左前缀原则

47.  慢日志

     -   会记录，sql查询速度慢、没有命中索引的 sql 语句

48.  sql注入

     -   -- 是mysql的注释

     ```sql
     select count(1) from user where name = "%s" and pwd = "%s"
     select count(1) from user where name = "echo" or 1=1 -- and pwd = "123"
     ```

     -   防止sql注入

     ```python
     # pymysql
     cursor.execute("select count(id) from user where name = %s and pwd = %s", ['echo', 123])
     # orm 已经处理过sql注入
     ```

49.  简述 redis 五大数据类型

     1.  strings
     2.  hashes
     3.  lists
     4.  sets
     5.  sorted sets

50.  redis 和 memcached 的区别？

     1.  数据类型：redis有5种，memcached只有1种字符串类型
     2.  redis可以持久化，memcached只能存储到内存中
     3.  redis支持高可用、memcached需要第三方工具
     4.  分布式集群：redis支持分布式集群，memcached不支持

51.  redis的AOF和RDB什么区别？

     1.  AOF：基于日志做的持久化，记录命令，通过执行命令恢复数据
         -   保证数据的完成性
         -   恢复速度相对较慢
     2.  RDB：基于快照做的持久化，定期对redis中的数据进行备份
         -   恢复速度相对较快

52.  redis的过期策略

     -   redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。**redis 提供 6种数据淘汰策略：**

     1.  **voltile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
     2.  **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
     3.  **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
     4.  **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
     5.  **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
     6.  **no-enviction**（驱逐）：禁止驱逐数据

53.  常见的bootstrap样式(很少)

     ```css
     container
     table
     form-control
     row
     md-col-6
     ```

54.  什么是响应式布局？

     -   根据用户设备不同，显示不同效果，内部使用`@media`属性

     ```css
     .pg-header{
             background-color:red;
         }
     
     @media (min-width:800px){
         .pg-header{
             background-color:green;
         }
     }
     ```

55.  怎么发送ajax请求

     ```js
     $.ajax({
         url:'...',
         type:"GET",
         data:{},
     	dataType:"JSON",			// 接收数据是json格式，否则收不到
         sucess:function(arg){
             ...
     	}
     })
     ```

56.  javascrpt中的this相关

     ```js
     name = 'henry'
     function f1(){
         console.log(this.name);		// 谁调用this就是谁，输出 henry，this是window
     }
     // window 相当于全局变量
     window.f1() or f1()
     
     // 自执行函数
     (function(arg){
         console.log(arg);
         console.log(this);			// this 是 window，默认是window
     })(123)
     
     info = {
         name:'echo', 
         age:19,
         func:function(){
             console.log(this.name);	// this 是 info，输出 echo
             function f1(){
                 console.log(this); // this 是 window，没有写默认是window
             }
             f1();
         }
     }
     info.func()						// 先打印 echo 在打印 henry
     ```

     ```js
     info = {
         name:'echo', 
         age:19,
         func:function(){
             console.log(this.name);
             var xxx = this;
             (function f1(){
                 console.log(xxx.name);
             })()
         }
     }
     info.func()                     // 先打印 echo 在打印 echo
     ```

57.  “同源策略”、跨域、 jsonp、cors ?

     1.  浏览器具有“**同源策略**”，即：浏览器**只能向当前所在的域发送Ajax**，如果向其他域发送请求，则浏览器就会报错。 
     2.  **跨域会报错**，因为浏览器具有浏览器具有同源策略。 但是，**同源策略不对 script 标签中的 src 属性限制**。
     3.  如能才能跳过浏览器的同源策略，让我们向别的域可以发送ajax请求并获取结果？
         1.  cors一个解决跨域的方案（**设置响应头**）。 主流
             -   跨域资源共享(CORS) 是一种机制
         2.  jsonp一个解决跨域的方案，是一种巧妙的机制，可以绕过浏览器的同源策略，实现跨域（**动态创建script标签**）。
             -   注意：**jsonp只能发get请求**
     4.  **扩展：域名、端口、二级域名不同都会引发跨域。** 

     ```python
     # cors，浏览器接收到时，会自动放行，支持所有网站
     ret['Access-Control-Allow-Origin'] = "*"
     ```

     -   使用 jsonp

     ```python
     # 使用 django
     def api(request):
         funcname = request.GET.get('callback')
         return HttpResponse("%s(百度)" % funcname)
     ```

     -   js

     ```js
     function sendMsg(){
         var tag = document.createElement('script');
         tag.src = '其他域/?callback=ffff';
         document.head.appendChild(tag);
         document.head.removeChild(tag);
     }
     function ffff(arg){
         console.log(arg);
     }
     ```

58.  python代码实现链表

     ```python
     class Node(object):
         def __init__(self, value, next):
             self.value = value
             self.next = next
             
     head = Node('head', None)
     last = head
     for i in range(5):
         node = Node('%s' % i, None)
         last.next = node
         last = node
     # ######### 查看链表关系 ##########
     print('原始链表信息为：')
     print(head.value)
     print(head.next.value)
     print(head.next.next.value)
     print(head.next.next.next.value)
     print(head.next.next.next.next.value)
     print(head.next.next.next.next.next.value)
     ```

59.  链表逆转

     ```python
     def reverse_linked_list(head):
         """
         链表逆置
         """
         if not head or not head.next:
             return head
      
         prev_node = None
         current_node = head
         next_node = head.next
      
         while True:
             current_node.next = prev_node
             if not next_node:
                 break
             prev_node, current_node = current_node, next_node
             next_node = current_node.next
         return current_node
     
     new_head = reverse_linked_list(head)
      
     print('逆置之后的链表')
     print(new_head.value)
     print(new_head.next.value)
     print(new_head.next.next.value)
     print(new_head.next.next.next.value)
     print(new_head.next.next.next.next.value)
     print(new_head.next.next.next.next.next.value)
     ```

60.  两个队列实现一个栈

     -   queue.Queue()、q.size()、q.get()、q.put(val)

     ```python
     import queue
      
     class Stack(object):
     
         def __init__(self):
             self.master_queue = queue.Queue()
             self.minor_queue = queue.Queue()
      
         def push(self, value):
             """
             入栈
             """
             self.master_queue.put(value)
      
         def pop(self):
             """
             出栈
             """
             if self.master_queue.qsize() == 0:
                 return None
      
             while True:
                 if self.master_queue.qsize() == 1:
                     value = self.master_queue.get()
                     break
                 self.minor_queue.put(self.master_queue.get())
             self.master_queue, self.minor_queue = self.minor_queue, self.master_queue
             return value
      
      
     obj = Stack()
     obj.push('henry')
     obj.push('echo')
     obj.push('dean')
      
     print(obj.pop())
     print(obj.pop())
     print(obj.pop())
     ```

61.  vue.js

     ```python
     https://www.bilibili.com/video/av51299056/?p=533
     ```

     1.  数据驱动视图
     2.  
     
     
