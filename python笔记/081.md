## 1. 校验器

```python
def validate_title(value):
  	if 'xx' in value:
      	raise serializers.ValitdatoinError
    return value
```

2. 局部校验

```python
def validate_title(self, value):
  	if 'xx' in value:
      	raise serializers.ValitdatoinError
    return value
```

- 全局校验

```python
# attrs为有序字典，所有数据
def validate(self, attrs):
    pass
```

- 自定义校验

```python
# 类似于Form组建中的自定义校验规则
title = serializers.CharField(max_length=32, validators=[my_validata, ])

def my_validata(value)
    pass
```

## 2. ModelSerializer

```python
class BookSerializer(serializers.ModelSerializer):
  	pub_info = serializers.SerializersMethodField(read_only=True)
    author_info = serializers.SerializersMethodField(read_only=True)
    
    def get_pub_info(self, obj):
      	return PublisherSerializer(obj.pub).data
      
    def get_pub_info(self, obj):
        return AuthorSerializer(obj.authors.all(), many=True).data
    
  	class Meta:
      	model = models.Book
        fields = '__all__'
        # 取值深度
        # depth = 1
        extra_kwargs = {
          	'pub':{'write_only':True},
          	'authors':{'write_only':True},
         }
```

## 1. 极验验证码和短信验证

- **下载python包：reqeusts、geetest、aliyun-python-sdk**

### 1. 设计login的url

- login使用CBV

```python
# 相当于初始化
url(r'^pc-geetest/register', views.pcgetcaptcha, name='pcgetcaptcha'), 
# 二次验证
url(r'^pc-geetest/ajax_validate', views.pcajax_validate, name='pcajax_validate'),  
# 登录校验
url(r'login.html', views.Login.as_view(), name='login'),
```

### 2. 使用对应的view函数

```python
# 行为验证初始化
def pcgetcaptcha(request):
	user_id = 'test'
	gt = GeetestLib(settings.PC_GEE_ID, settings.PC_GEE_KEY)
	status = gt.pre_process(user_id)
	request.session[gt.GT_STATUS_SESSION_KEY] = status
	request.session["user_id"] = user_id
	response_str = gt.get_response_str()
	return HttpResponse(response_str)
# 二次验证
def pcajax_validate(request):
    if request.method == "POST":
        gt = GeetestLib(settings.PC_GEE_ID, settings.PC_GEE_KEY)
        challenge = request.POST.get(gt.FN_CHALLENGE, '')
        validate = request.POST.get(gt.FN_VALIDATE, '')
        seccode = request.POST.get(gt.FN_SECCODE, '')
        status = request.session[gt.GT_STATUS_SESSION_KEY]
        user_id = request.session["user_id"]
        if status:
        		result = gt.success_validate(challenge, validate, seccode, user_id)
      	else:
        		result = gt.failback_validate(challenge, validate, seccode)
      	if result:
            result = {"status": "success"}
            # 二次校验成功
            # 发短信，并存储code
            code = sms.getcode()
            phone = request.POST.get('phone')
            sms.send_sms(phone, code)
            request.session['code'] = code
     	 	else:
        		result = {"status": "fail"}
      	return HttpResponse(json.dumps(result))
    return HttpResponse("error")
```

### 3. 修改js

1. 根据业务逻辑进行修改**js**流程
2. 添加和修改错误提醒
3. 调整二次验证的

```js
// 短信+极验行为验证
var num = 60;
$('.getcode').click(function () {
    var flag = /^1[3-9][0-9]{9}$/.test($('#phone').val());
    if (!flag) {
        $('.error-wrap').show();
        $('.sms-login .phone').addClass('error-box');
        return;
    }
 		// 判断极验图片验证是否合法
    validate = obj.getValidate();
    if (!validate) {
        $('.error-wrap').show();
        $('.error-wrap span').text('请先点击按钮进行验证');
        $('.sms-login .validate').addClass('error-box');
        return;
    }
		// 二次验证，并进行短信发送，flag用于区分登录方式
    $.ajax({
        url: "/pc-geetest/ajax_validate", // 进行二次验证
        type: "post",
        dataType: "json",
        data: {
            flag:'sms',
            phone: $('#phone').val(),
            csrfmiddlewaretoken: $("[name='csrfmiddlewaretoken']" ).val(),
            geetest_challenge: validate.geetest_challenge,
            geetest_validate: validate.geetest_validate,
            geetest_seccode: validate.geetest_seccode
          }
    });
  // 获取验证码倒计时
    var _this = $(this);
    $('.countdown').find('span').text(num);
    var timer = setInterval(function () {
      	if (num > 0) {
            $('.countdown').find('span').text(num--);
            _this.hide();
            $('.countdown').show();
      	} else {
            clearInterval(timer);
            num = 60;
            _this.show();
            $('.countdown').hide();
      }
    }, 1000)
  	});

		var obj = null;
		//滑动验证码 geetest网站:https://docs.geetest.com/install/deploy/server/python
    var handlerEmbed = function (captchaObj) {
      	obj = captchaObj;
        $("#embed-submit").click(function (e) {
            var validate = captchaObj.getValidate();
            if (!validate) {
                $("#notice")[0].className = "show";
                setTimeout(function () {
                  	$("#notice")[0].className = "hide";
                }, 2000);
                e.preventDefault();
            }
      });
      // 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode
      captchaObj.appendTo("#embed-captcha");
      captchaObj.onReady(function () {
        $("#wait")[0].className = "hide";
      });
    };
    $.ajax({
        // 获取id，challenge，success（是否启用failback）
        url: "/pc-geetest/register?t=" + (new Date()).getTime(), // 加随机数防止缓存
        type: "get",
        dataType: "json",
        success: function (data) {
            // 使用initGeetest接口
            // 参数1：配置参数
            // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件
            initGeetest({
              gt: data.gt,
              challenge: data.challenge,
              product: "float", // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效
              offline: !data.success, // 表示用户后台检测极验服务器是否宕机，一般不需要关注
              new_captcha: data.new_captcha,
              api_server: "api.geetest.com"
          }, handlerEmbed);
      }
    });
```

- **js中的正则表达式**

```js
phone_num = $('#phone').val()
flag = /^1(3-9)[0-19]{9}$/.test(phone)
if (!flag){
  	return
}
...
```

- **极验验证流程**

![geetest_justify](/System/Volumes/Data/Users/henry/Documents/截图/Py截图/geetest_justify.jpg)
