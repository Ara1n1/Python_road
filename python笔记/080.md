# RESTful

## 1. REST

- Resensentational State Transfer

maple-shaw/p/

- 前后端分离
- URI：统一资源标志符
  - URL：统一资源定位符
  - URN：Name

## 表现层(Respresentation)

## 状态转化(State Transfer)

URI：表示一个资源

4种请求方式表示4种操作

1. GET 获取资源
2. POST 新建资源
3. PUT 更新资源
4. DELETE 删除资源

## 2. RESTful API设计

- api与用户的通信协议，推荐使用https
- 域名
  - https://api.example.com 尽量将api部署在专用域名(会存在跨域问题)
  - https://example.org/api/ api很简单

- 版本
  - url 如：https://api.example.com/v1/
  - 请求头  跨域时，引发发送多次请求
- 路径，网络上任何东西都是资源，均使用名词表示(可复数)
- method
  - GET 获取服务器上的资源，返回资源列表或一个资源
  - POST 新建资源，返回新建资源
  - PUT 在服务器更新资源(客户端提供改变后的完整资源)，返回更改后的资源
  - PATCH 在服务器更新资源(更改某些数据)
  - DELETE 删除资源，返回空/提示
- 过滤，通过url上传参形式
  - https://api.example.com/v1/zoos?limit=10
  - https://api.example.com/v1/zoos?offset=10
  - ...
- 状态码
  - 200 ok
  - 201 created  [POST/PUT/PATCH]：用户新建或修改数据成功
  - 201 Accepted 表示需要排队，异步
  - 204 No content [DELETE]：用户删除数据成功
- 错误处理，状态码4xx，应返回错误信息，error当作key
- Hypermedia API 返回关联的数据时，尽量返回url地址
- www.ruanyifeng.com/blog/2014/05/restful_api.html



- jsonresponse可以序列化datetime类型

```python
JsonResponse(list(), safe=False, json_dumps_params={'ensure_ascill': False})
```

- django提供的序列化器

```python
from django.searilizers
```

## 使用rest_framwork流程

### 1. 注册rest_framework app 

- **不使用序列化器时**，多对多关系对应多个值时，**会分别为关联值构造不同的字典**
- 结构：**[{},{}...]**
- rest_framework的**Response()不能序列化对象**

```python
from rest_framework.views import APIView
from rest_framework.response import Response

class BookListView(APIView):
  	def get(self, request, *args, **kwargs):
      	all_book = models.Book.object.all().values('id', 'title', 'auther__name')
        return Response(all_book)
```

- **使用序列化器精简数据** 

```python
from rest_framework import serializers

class Publisherserializer(serializers.Serializer):
  	name = serializers.CharField()

class AuthorSerializer(serializers.Serializer):
  	id = serializers.IntegeField()
  	name = serializers.CharField()
   
class BookSerializer(serializers.Serializer):
  	title = serializers.CharField()
    price = serializers.DecimalField(max_digits=6, decimal_places=2)
    pub_date = serializers.DateTimeField()
    # 外键
    # pub_id = serializers.IntegeField()
    pub = Publisherserializer(required=False, read_only=True)
    # 多对多，需要实现get_authors 方法
    authors = serializers.SerializerMethodField(read_only=True)
    
    # post请求
    post_pub = serializers.CharField(write_only=True)
    post_authors = serializers.ListField(write_only=True)
    
    def get_authors(self, obj):
      	ser_obj = AuthorSerializer(obj.authors.all(), many=True)
      	return ser_obj.data
    # post操作调用
    def create(self, validated_data):
      	book = models.Book.objects.create(
            title=validated_data['title'],
            price=validated_data['price'],
            pub_date=validated_data['pub_date'],
            pub_id=validated_data['post_pub'],
        	)
        book.authors.set(validated_data['post_author'],)
        return book
    # put操作调用
    def update(self, instance, validated_data):
      	instance.title=validated_data.get('title', instance.title)
        instance.price=validated_dataget('price', instance.price)
        instance.pub_date=validated_dataget('pub_date', instance.pub_date)
        instance.pub_id=validated_dataget('pub_id', instance.pub_id)
        instance.save()
        instance.authors.set(validated_data.get('post_author', instance.authors.all()),)
        return instance
        	
```

- **导入view.py中使用**

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from 
class BookListView(APIView):
  	def get(self, request, *args, **kwargs):
      	all_book = models.Book.object.all()
        ser_obj = BookSerializer(all_book, many=True)
        print(ser_obj)
        # .data获取序列化结果
        return Response(ser_obj.data)
      
     def post(self, request, *args, **kwargs):
      	# 必须使用application/urlencoding
      	print(request.POST)
        # 使用必须使用application/json, 获取的是dict类型，request发生了变化
        print(request.data, type(request.data))
        ser_obj = BookSerializer(data=request.data)
        if ser_obj.is_valid():
          	ser_obj.save()
            return Response(ser_obj.data)
         return Response(ser_obj.errors)
      
      def put(self, request, pk, *args, **kwargs):
          ser_obj = BookSerializer(data=request.data, partial=True)
          if ser_obj.is_valid():
              ser_obj.save()
              return Response(ser_obj.data)
           return Response(ser_obj.errors)
        
      def delete(self, request, pk, *args, **kwargs):
        	obj = models.Book.objects.filter(pk=pk).first()
          if obj:
            	obj.delete()
              return Response({'msg': '删除成功'})
           return Response({'msg': '数据不存在'})
```

- 原来的request = request._request

## 修改

### 1.设计url

```python
url(r'^book/(\d+)', BookListView.as_view())
```











