## 10.6 mysql索引

### 1. 存储过程

```mysql
# 1.准备表
create table s1(id int,
                name varchar(20),
                gender char(6),
                email varchar(50));
# 2.创建存储过程，实现批量插入记录
delimiter $$ #声明存储过程的结束符号为$$
create procedure auto_insert1()
BEGIN
    declare i int default 1;
    while(i<3000000)do
        insert into s1 values(i,'henry','male',concat('henry',i,'@qq.com'));
        set i=i+1;
    end while;
END$$ #$$结束
delimiter ; #重新声明分号为结束符号
# 3.查看存储过程
show create procedure auto_insert1\G 
# 4.调用存储过程
call auto_insert1();
# 在写入的时候不更新索引表，只针对myisam生效
ALTER TABLE table_name DELAY_KEY_WRITE= 1;
```

### 2. 初识索引

- **索引**是应用程序设计和开发的一个重要方面。**若索引太多**，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响，要找到一个平衡点，这对应用程序的性能至关重要。
- **场景**：某台MySQL服务器iostat显示磁盘使用率一直处于100%，经过分析后发现是由于开发人员添加了**太多的索引**，在删除一些不必要的索引之后，磁盘使用率马上下降为20%。可见索引的添加也是非常有技术含量的。

#### 2.1 概念

- **索引在MySQL中也叫是一种“键”，是存储引擎用于快速找到记录的一种数据结构**
- 建立起的一个在存储表阶段的一个存储结构能够在查询的时候加速
- 出于效率方面的考虑，InnoDB数据表的**数据行级锁定实际发生在它们的索引上**，而不是数据表自身上。显然，数据行级锁定机制只有在有关的数据表有一个合适的索引可供锁定的时候才能发挥效力

#### 2.2 索引的重要性

1. 读写比例：10:1，读的速度是数据库的关键

   - 读取硬盘的io操作时间要远远长于cpu执行指令的时间
   - 尽量减少io次数才是关键
   - 索引对性能的影响随着数据量的增加愈发重要
   - 访问磁盘的成本大概是访问内存的十万倍左右

2. 磁盘IO与预读性原理，一次读取一个**block**块

   - 访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是**机械运动**，每次读取数据花费的时间可以分为**寻道时间**、**旋转延迟**、**传输时间**三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，
   - 一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，

   - 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为**一页(page)**。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
   - 4096bytes, 4k(linux)
   - oracle会一次读取2个block块
   - mysql会一次读取4个block块

#### 2.3 索引原理

- **本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

#### 2.4 数据库存储方式

1. **平衡树 balance tree b树**

   1. 写入数据：速度较慢，需要整理数据

   2. 范围查询b树不占优势(root、leaf、branch)

   3. **在b树基础上的改良**：b+树(innodb 默认结构)

      - **目的**：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。
   - 分支节点和根节点不在存储实际数据
      - 让分支和根节点能存储更多的索引信息
      - 在叶子节点之间加入**双向的链式结构**方便在查询中的范围条件
      - **索引字段要尽量的小**
      
      - **索引的最左匹配特性**

   4. **索引字段要尽量的小**：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前**数据表的数据为N**，每个**磁盘块的数据项的数量是m**，则有**h=㏒(m+1)N**，当数据量N一定的情况下，m越大，h越小；而**m = 磁盘块的大小 / 数据项的大小**，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

   5. **索引的最左匹配特性**：当b+树的数据项是**复合的数据结构**，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候**name就是第一个比较因子**，必须要先根据**name来搜索才能知道下一步去哪里查询**。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即**索引的最左匹配特性**。

2. **树的高度**会影响索引的效率

   - 对哪一列创建索引，选择尽量**短的列做索引**
   - 对**区分度高的列**建索引，重复率超过10%就不适合创建索引
   - 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(\*)，表示字段不重复的比例。

3. 索引特点

   - 加速读取，但牺牲了写的速度
   - 每个节点存储**数据的地址**

4. mysql中所有的b+树索引的高度都基本上控制在**3**层

   - io操作的次数非常稳定(3)
   - 有利于通过范围查询
   - 在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2~4次的IO意味着查询时间只需要0.02~0.04秒。

#### 2.4 聚集索引和辅助索引

1. **数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）**

2. **聚集索引**：数据直接存储在树结构的叶子节点

   - 如用户需要查找一张表，查询最后的10位用户信息，由于B+树**索引是双向链表**，所以用户可以快速找到最后一个数据页，并取出10条记录

   ```mysql
   # InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。
   1. 而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。
   2. 聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。
   # 如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。  
   1. 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。
   # 由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。
   1. 在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。
   2. 此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。
   ```

   - 可以通过添加主键的方式完成索引的建立

   ```mysql
   alter table t1 add primary key(id);
   ```

   - **聚集索引的好处之一：**它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。
   - **聚集索引的好处之二：范围查询（range query）**，即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可。

3. **辅助索引**：数据不直接存储在树中

   - **需要回表**
   - 表中除了**聚集索引外**其他索引都是**辅助索引（Secondary Index，也称为非聚集索引）**，与聚集索引的区别是：**辅助索引的叶子节点不包含行记录的全部数据**。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（**bookmark**）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。

   ![innodb辅助索引](/Users/henry/Documents/截图/Py截图/innodb辅助索引.png)

   - **辅助索引**的存在并**不影响数据在聚集索引中的组织**，因此每张表上可以有多个辅助索引，但**只能有一个聚集索引**。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得索引的主键，然后再通过主键索引来找到一个完整的行记录。

4. **聚集和辅助索引对比**

   1. **聚集索引与辅助索引相同的是**：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即**高度是平衡的**，叶子结点存放着所有的数据。**聚集索引与辅助索引不同的是**：叶子结点存放的是否是一整行的信息
   2. **聚集索引**
      - 纪录的索引顺序与顺序相同，因此更适合between and和order by操作
      - 叶子结点直接对应数据从中间级的索引页的索引行直接对应数据页
      - 每张表只能创建一个聚集索引
   3. 非聚集索引
      - 索引顺序和物理顺序无关
      - 叶子结点不直接指向数据页
      - 每张表可以有多个非聚集索引，需要更多磁盘和内容
      - 多个索引会影响insert和update的速度

5. innodb**中聚集索引和辅助索引**并存**（都是b+树）

   - 数据和索引存在一起
   - 除了**主键**之外所有的索引都是**辅助索引**

6. myisam中只有**辅助索引**

   - 叶子节点存储数据的**主键**的值
   - 通过主键再查找数据
   
7. **需要注意的是**：**innodb**表的索引会存放于**s1.ibd**文件中，而**myisam**表的索引则会有单独的索引文件t**able1.MYI**

8. MySAM索引文件和数据文件是分离的，**索引文件仅保存数据记录的地址**。而在innodb中，表数据文件本身就是按照B+Tree（BTree即Balance Tree）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.

### 3. 使用索引

#### 3.1 索引两大类型

1. 我们可以在创建上述索引的时候，为其指定索引类型，**分两类**：
   - **hash类型的索引**：查询单条快，范围查询慢
   - **btree类型的索引**：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）
2. 不同的存储引擎支持的索引类型也不一样
   - InnoDB 支持事务，**支持行级别锁定**，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
   - MyISAM 不支持事务，**支持表级别锁定**，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
   - Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
   - NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
   - Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；
3. 除此之外还有全文索引，即**FULLTEXT**用于搜索**很长一篇文章**的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择**第三方软件如Sphinx**，专门来做全文搜索。
4. 其他的如空间索引SPATIAL，了解即可，几乎不用

#### 3.2 索引的种类

1. **primary key** 主键    **自带聚集索引** 和约束：非空+唯一
   - 联合主键
2. **unique** 区分度最高  **自带辅助索引** 和约束：唯一
   - 联合唯一
3. **index 辅助索引**         辅助索引        没有约束
   - 联合索引，根据两个字段建立索引

#### 3.3 使用索引

```mysql
# 方法一：创建表时
create table 表(字段...,
               index|unique|fulltext|spatial|key 
               索引名称 on 表(字段1,字段2...));
# 方法二：CREATE在已存在的表上创建索引,常用方法
create index(索引类型，通常使用index) 索引名称 on 表(字段1,字段2...);
# 方法三：ALTER TABLE在已存在的表上创建索引
alter table 表名 add index 索引名称 on 表(字段1,字段2...);
# 删除索引
drop index 索引名 on 表名字;
```

- 不添加索引的时候肯定慢
- 查询的字段不是索引字段也慢

#### 3.4 索引不生效

- 范围、条件字段是否参与计算、列的区分度、列的长度、条件 and/or，联合索引的前缀问题

1. 要查询的范围越大，索引效果越不明显，越费时
   - 和比较运算符有关的，大于、小于、不等于、between … and ...
   - like，结果范围大，like **abc%可以生效**，**%abc索引不生效**

```mysql
select * from 表 where id between 1000000 and 1000005;
# 使用like
select * from 表 where emial like '%abc';
```

2. 一列的区分度不高
   - 即范围过大

```mysql

```

3. 索引列不能参与计算

```mysql
select * from s1 where id*10 = 1000000;
```

4. 对两列内容进行条件查询

- and：优先选择有索引且树形结构更好的进行查找，缩小范围
- or：如果存在没有索引项，索引效果不生效，只是根据条件从左到右依次筛选
  - 条件中带有or的想要命中索引，这些条件中所有列都是索引列

#### 3.5 联合索引

- 查找总是两个(多)个条件

```mysql
create index ind_mix on s1(id, email);
```

1. 索引不生效情况
   1. 在联合索引中如果使用**or**条件索引不生效
   2. 条件必须含有创建索引的第一个字段(**最左前缀原则**)
      - id列可以命中索引
   3. 整个条件中，一开始**出现模糊匹配的那一刻，索引就失效**
2. 应用场景
   1. 只对a，b，c条件进行索引
   2. **不**对b，对c**进行单列索引**
3. 单列索引
   1. 区分度高的列，建立索引，条件的范围尽量小
   2. 条件中的列不参与计算，使用and 作为条件连接
   3. 使用or连接多个条件，在满足上述条件的基础上，对or相关的所有列创建索引

#### 3.6 覆盖/合并索引

- 如果使用索引作为条件查询，查询完毕之后，不需要回表查**即覆盖索引**
- 对两个字段分别创建索引，由于sql调价你让两个索引同时生效，那么这个时候这两个索引就成为了**合并索引**。

#### 3.7 执行计划

```mysql
# 执行计划，并不会真正执行sql语句，给出一个执行计划
explain select id from s1 where id = 1000000;
```

- 执行计划使用场景
  1. 测试sql语句是否可以满足数据量多的情况下的效率

![sql explian参数](/Users/henry/Documents/截图/Py截图/sql explian参数.png)

- 建表、使用sql需要注意
  - char代替varchar
  - 连表代替子查询
  - 创建表的时候，固定长度的字段在前面

#### 3.8 慢查询优化流程

![sql 慢日志流程](/Users/henry/Documents/截图/Py截图/sql 慢日志流程.png)

1. 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
2. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
3. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
4. order by limit 形式的sql语句让排序的表优先查
5. 了解业务方使用场景
6. 加索引时参照建索引的几大原则
7. 观察结果，不符合预期继续从0分析

### 4. 库的备份与恢复

```mysql
# 语法：
mysqldump -h服务器 -u用户名 -p密码 数据库名 > 备份文件.sql
# 示例：
# 单库备份
mysqldump -uroot -p123 库名 > 备份文件名(路径)
mysqldump -uroot -p123 db1 table1 table2 > db1-table1-table2.sql
# 多库备份
mysqldump -uroot -p123 --databases db1 db2 mysql db3 > db1_db2_mysql_db3.sql
# 备份所有库
mysqldump -uroot -p123 --all-databases > all.sql 
```

```mysql
# 方法一：
mysql -u用户名 -p密码  库名 < 备份文件名 
# 方法二：
mysql> use db1;
# 关闭二进制日志，只对当前session生效
mysql> SET SQL_LOG_BIN=0;  
mysql> source /root/db1.sql
```






