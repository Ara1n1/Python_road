# 1. 数据分析

-   数据分析：把隐藏在一些看似杂乱无章的数据背后的信息提炼出来，总结出所研究对象的内在规律
-   数据分析三剑客：Numpy，Pandas，Matplotlib
-   Numpy与Padas是数据结构、Matplotlib绘图使用

## 0. 环境准备

```python
# 环境变量 for zsh，并为 anaconda 的pip命别名
export PATH=$PATH:/Applications/anaconda3/bin
alias cpip="/Applications/anaconda3/bin/pip"
source ~/.zhsrc
```

## 1. numpy

-   **NumPy(Numerical Python)**：Python语言的一个扩展程序库，支持大量的维度数据与矩阵运算，针对数组提供大量的数学函数库。

### 1. 使用np.array()创建

-   数组

```python
import numpy as np
# 一维数组
np.array([1,2,3])
# 二维数组
np.array([[1,2,3], [4,5,6]])
# 返回值优先级：str > float > int
```

-   matplotlib绘图

```python
import matplotlib.pylab as plt
# 返回一个数组，图片是三维数据
img_arr = plt.imread('./cat.jpg')
plt.imshow(img_arr)
plt.imshow(img_arr-100)
```

### 2. 使用np的routines

-   linspace：等差数列

```python
# 平均生成 num 个 start-stop数据
np.linspace(start, stop, num)
```

-   arange：等差数列

```python
# start 默认是 0， step默认是 1, 给定 step 必须有start
np.arange([start,] stop[, step,], dtype=None)
# 不包含 10
np.arange(0, 10, 2)
```

-   random.randint()：随机数

```python
# [low, high)，high=None表示 [0-low), size=(1,2,3...)表示维度
np.random.randint(randint(low, high=None, size=None, dtype='l')
# 固定随机性，随机因子(系统时间)
np.random.seed(10)
np.random.randint(0,100, size=(4,5))
```

-   random.random(size)

```python
# 默认大小是 0-1
np.random.random(size=(4,5))
```

### 3. ndarray属性(3)

```python
arr.shape					# (4,5)，返回的是数组的形状
arr.size					# 元素个数
arr.dtype					# ('int64')，数据类型
```

### 4. 操作(4)

-   索引

```python
arr[1]						# 第一个元素，索引从 0 开始
arr[2, 3]					# 第二行第三列元素
```

-   切片

```python
arr[0:2]					# 前两行
arr[:, 0:2]					# , 左边是行，右边是列
arr[::-1]					# 行倒序
arr[:, ::-1]				# 列倒序
arr[:, ::-1, :]
```

-    变形：参数是一个tuple

```python
arr.reshape()
# 容量必须刚刚好
arr.reshape((20,))
arr.reshape((1, 20))
arr.reshape(1, 20)
# 自动计算行数
arr.reshape((-1, 4))
```

-   级联
    -   数据的拼接，注意行或列的长度

```python
# axis=0 表示作用于行(纵向拼接)，axis=1作用于列(横向拼接)
np.concatenate((arr, arr), axis=0)
```

-   算术运算
    -   广播机制：如果两个数组的后缘维度(从末尾开始算起的维度)的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会在缺失维度和(或)轴长度为1的维度上进行。

```python
b = np.array([[1],[2],[3]])
a = np.array([1,2,3])
b-a
-->	array([[ 0, -1, -2],
       [ 1,  0, -1],
       [ 2,  1,  0]])
```

### 5. ndarray聚合

-   np.sum/mean

```python
arr.sum(axis=None)				# 计算所有元素的和
arr.sum(axis=0)					# 作用于列，数据并到一行。列的和
arr.sum(axis=1)                 # 作用于行，数据并到一列。行的和
arr.mean(axis=None/0/1)			# 平均数
```

-   其他

```python
np.sqrt(arr)					# 开方
np.prod(arr) 					# 所有元素相乘

np.min(arr) 					# 最小值
np.max(arr) 					# 最大值
np.std(arr) 					# 标准差
np.var(arr) 					# 方差
np.median(arr) 					# 中数
np.power(arr,2) 				# 幂运算
np.argmin(arr) 					# 最小值的下标
np.argmax(arr) 					# 最大值的下标
np.inf 							# 无穷大
np.exp(10) 						# 以e为底的指数，e**10
np.log(10) 						# 对数，e为底
```

### 6. ndarray排序

-   sort排序

```python
# axis默认-1：表示按照上次的排序规则排序
# axis=0：表示按照列元素排序，1表示行元素排序
np.sort(arr, axis=-1, kind='quicksort', order=None)

# 列元素排序，列有序，arr被修改
arr.sort(axis=0)
# 列元素排序，列有序，不改变原数据
np.sort(arr, axis=0)
```

#### Note(2)

1.  axis=0：表示针对行进行计算或排序，**列有序**
2.  axis=1：表示针对列进行计算或排序，**行有序**

## 2. pandas

-   导入需要的包

```python
import pandas as pd
from pandas import Series, DataFrame
import numpy as np
```

### 1. Series

#### 1. 创建和去重

-   是一种类似与一维数组的对象
    -   values：一组数据（ndarray类型）
    -   index：相关的数据索引标签

-   创建：由列表或numpy数组创建
    -   默认索引为0到N-1的整数型索引
    -   **一定是一维的数据结构**
    -   隐式索引和显示索引可以共存

```python
Series(data=[1,2,3])			 		# 隐式索引
Series(data=[1,2,3], index=[a,b,c])		# 显示索引，提高可读性
Series(data=np.random.randint(0,100, size=(4)))
```

```python
s = Series(data=[1,1,1,2,3,4,5,5,6])
# 去重
s.unique()
# NaN表示空，浮点类型
运算：只能针对索引对齐的数据运算，否则为NaN
# 空值检测
pd.isnull(arr) 或 s.isnull()
pd.notnull(arr) 或 s.notnull()
s[[True, True, False, False]]
s[s.notnull()]							# 空值过滤
```

#### 2. Series的索引

-   可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多个索引（此时返回的是一个Series类型）。
-   显式索引
    -   使用index中的元素作为索引值
    - 使用s.loc[]（推荐）:注意，loc中括号中放置的一定是显示索引
    - 注意，此时是闭区间

```python
s = Series([1,2,3,4], index=['a', 'b', 'c', 'd'])
```

-   隐式索引
    -   使用整数作为索引值
    -   使用`s.iloc[]`（推荐）`s:iloc`中的中括号中必须放置隐式索引
    -   注意，此时是半开区间

```python
s = Series([1,2,3,4])
```

#### 3. 切片：隐式索引和显示索引切片

-   显示索引切片：index和loc

```python
s['a':'b']								# ['a', 'b']
s.loc['a':'b']
```

-   隐式索引：iloc

```python
s[0:3]									# [0, 3)
s.iloc[0:3]
```

#### 4. Series基本概念

-   可以通过shape，size，index,values等得到series的属性

```python
s.index									# 索引
s.values								# 值
s.size									# 长度
s.shape									# (n,)
```

-   可以使用s.head(),tail()分别查看前n个和后n个值

```python
s.head(2)
s.tail(2)
```

-   去重

```python
s.unique()
```

-   Series的运算：索引一致则相加，不一致则为Na

```python
# + - * /
# add() sub() mul() div() 

# s1 + s2， 索引相同则相加，不同则保留切 +fill_value(float类型)
s1.add(s2,fill_value=0)
s1.mul(s2,fill_value=1)
```

#### Note(2)

1.  默认格式：dtype: int64
2.  Series之间的运算，自动对齐不同索引的数据，如果索引不对应，则补NaN

### 2. DataFrame

#### 1. DataFrame简介

-   DataFrame是一个【表格型】的数据结构。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。**DataFrame既有行索引，也有列索引**。
    1.  行索引：index
    2.  列索引：columns
    3.  值：values

#### 2. 创建DataFrame

-   最常用的方法是传递一个字典来创建。DataFrame以字典的键作为每一【列】的名称，以字典的值（一个数组）作为每一列。
    1.  此外，DataFrame会自动加上每一行的索引。
    2.  使用字典创建的DataFrame后，则columns参数将不可被使用。
    3.  同Series一样，若传入的列与字典的键不匹配，则相应的值为NaN。

```python
# 使用ndarray创建DataFrame
df = DataFrame(data=np.random.randint(0,100, size=(3,3)), index=('a', 'b', 'c'), columns=('1', '2', '3'))

# 使用 dic 创建DataFrame
dic = {
    '张三':[11,22,33,44],
    '李四':[55,66,77,88]
}
df_score = DataFrame(data=dic,index=['语文','数学','英语','理综'])
```

```python
# 属性：shape、index、colums、values
df.shape / .index  /.colums /.vlues
```

#### 3. DataFrame的索引

-   数据准备

```python
df=DataFrame(np.random.randint(0,100, size=(3,3)), index=('a','b','c'), columns=('A','B','C'))
```

-    **对列进行索引(2)**
    -   通过类似字典的方式  df['q']
    - 通过属性的方式  df.q
    -  可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。

```python
df.A / df['A']					# 取一列，即一个 Series对象
df[['A', 'B']]					# 取 A、B两列
```

-   **对行进行索引(2)**
    - 使用.loc[]加index来进行行索引
    - 使用.iloc[]加整数来进行行索引
    - 同样返回一个Series，index为原来的columns。

```python
df.loc[['a','b']]				# 取 a、b 两行
df.iloc[[0, 1]]					# 取 a、b 两行
```

-   **对元素索引**

```python
df.loc['a', 'C']				# 取一个值，类似坐标取值
df.loc[['a', 'c'], 'C']			# 取多个值
```

#### 4. 切片

-   【注意】 直接用中括号时
    -   索引表示的是列索引
    -   切片表示的是行切片

```python
# 切出前两行
df['a':'b']
df[0:2]
# 切出前两列
df.loc[:, 'A':'B']
df.iloc[:, 0:2]
# 按照行列切片
df.loc['a':'b', '1':'2']
```

#### 5. 运算

-   和Series一样
    -   在运算中自动对齐不同索引的数据
    -   如果索引不对应，则补NaN

## 3.  股票示例

-   df.to_save('xxx.csv')
-   pd.read_csv('xxx.csv', index_col='date', parse_dates=True)：把字符串日期转为 Timestamp
-   df.drop(labels=['列名'], axis=1 ,inplace=True)：删除某一列
-   df['close'].shift(1)：向下移动一个单元，对齐其他列的下一行
-   new_df.resample('M').first()：获取每个月的第一条
-   new_df.resample('A').last()：获取每年的最后一条

```python
# tushare 股票数据获取模块
import tushare as ts
import pands as pd

# 获取 股票代码 600519 从2001.1.1的交易数据
df = ts.get_k_data(code='600519',start='2000-01-01')
# 把数据保存到本地 maotai.csv 中
df.to_csv('./maotai.csv')
# 使用 pandas 读取文件
df = pd.read_csv('./maotai.csv')
# 删除某一列
df.drop(labels=['Unnamed: 0'], axis=1, inplace=True)
# 把字符串的日期转换为 Timestamp 类型
df = pd.read_csv('./maotai.csv',index_col='date',parse_dates=['date'])
# 查看转换结果
df.index[0]
df.columns[0]
```

-   输出该股票所有收盘比开盘上涨3%以上的日期。

```python
# (收盘-开盘)/开盘 > 0.03
df[(df.open - df.close)/df.open > 0.03]
#将行索引取出
df.loc[(df['close'] - df['open']) / df['open'] > 0.03].index
```

-   输出该股票所有开盘比前日收盘跌幅超过2%的日期。

```python
# (开盘-前日收盘)/前日收盘  < -0.02
df[(df.open - df.close.shift(1)) / df.close.shift(1) < -0.02].index
```

-   假如我从2010年1月1日开始，每月第一个交易日买入1手股票，每年最后一个交易日卖出所有股票，到今天为止，我的收益如何？

```python
# 2010-2019, M：表示按月份取，A：表示按年取
new_df = df['2010-01-01':'2019-09-03']
df_monthly = new_df.resample('M').first()
# 除了最后一条数据
df_yearly = new_df.resample('A').last()[:-1]

# 计算买入股票花费
cost = df_monthly['open'].sum() * 100
recv = df_yearly['open'].sum() * 1200
recv = 900 * new_df[-1:]['open'] + recv
recv - cost
```













