## 1. 文件操作

### 1. mkdir

#### 用法

`Usage: mkdir [OPTION]... DIRECTORY…`

#### 参数(2)

1. -p：创建多层目录
2. -v：显示创建的过程如：-pv

```SHELL
mkdir test1 test2 ...
mkdir test{1..10}
mkdir -p test/test1/test2...
# 递归创建目录
mkdir -p {s1, s2}/{ss1, ss2}/{sss1, sss2}
```

- 删除**空目录**

```SHELL
# 只能删除空目录
rmdir test1
# 递归删除空目录
mkdir -p s1/s2/s3
rmdir -p s1/s2/s3
```

### 2. tree

#### 参数(2)

1. -L：指定查看目录层级
2. -d：只显示目录

```SHELL
yum install -y tree		# 需要配置yum源
tree 目录
tree -L 2
tree -d
```

### 3. 链接文件

#### 1. 软链接

1. 相当于快捷方式
2. 文件大小为：链接文件路径的字符数
3. 删除源文件：软链接不能用
4. 可以对目录做软链接
5. 可以跨越分区

```SHELL
ln -s 源文件 目标文件	# 生成软链接
ln -s b c
```

#### 2. 硬链接

1. 指向同一磁盘位置
2. 将文件的引用次数+1
3. 删除源文件：硬链接只是该文件引用次数 -1，目标文件不受影响
4. 不能对目录做硬链接
5. 不能跨越分区

```SHELL
ln 源文件 目标文件	# 生成硬链接
```

- **目录引用次数一般为2，其内部有一个链接 .** 
- 目录引用次数 = 2 + 目录中的文件数(目录和文件)

#### 3. 查看文件类型

```SHELL
file 文件名
```

## 2. 输入输出

### 1. 输入、输出

1. 标准输入：接收键盘的输入 **stdin 0**
2. 标准输出：默认输出到终端 **stdout 1**
3. 错误输出：默认输出到终端 **stderr 2**

### 2. I/O重定向

- 把输出和错误信息重定向到文件或其他位置
- `>` 覆盖，把**stdout**重定向到文件中
- 2> 覆盖，把**stderr**重定向到文件中
- &> 覆盖，把**stdout /stderr**重定向到文件中
- `>>`追加
- 2>>
- &>>

```SHELL
# hhhhh不存在，默认显示到文件，
ls /hhhhh 2> err.log
# 把所有输出重定向到data.log文件
(ls ; ls /hhhhh) &> data.log
# 把所有输出重定向到data.log文件
ls / /hhhhh &> data.log
# 分开输出执行信息和错误信息
ls / /hhhhh >info.log 2> error.log
ls / /hhhhh >info.log 2> &1
# 无限接收，输出信息不显示
ls / /hhhhh &> /dev/null
# 无限输出
if = /dev/zero

echo 哈哈哈哈 > a.log
echo 嘻嘻嘻嘻 > a.log
echo 嘻嘻嘻嘻 >> a.log
# a.log文件不存在会新建，存在会清空
>a.log
```

- 多行输入

```SHELL
# EOF结束，多行输入，结束时生成(保存)该文件
cat > f1 <<EOF(自定义)
# ctrl + c/d 结束，只要回车立即生成(保存)文件
cat > f4
# EOF：约定俗称的，end of file
```

### 3. tr

- 替换、压缩和删除字符

#### 1. 参数

1. -t：截断替换
2. -d：删除
3. -s：压缩，去重
4. -c：取反

```SHELL
# 输入ab显示12
tr ab 12
# 输入abc显示122，不足位数取最后一位去补
tr abc 12
# 截断替换
tr -t abcd 12
# 循环删除
tr -d abcd
# 此时重定向不能为原文件，如果为原文件，则文件会被清空
tr -d abc < issue > issue
tr -d abc < issue > issue2
# 压缩，去重
tr -s a
# 取反去重
tr -sc abc
# 取反去重，ctrl + d 结束
tr -dc abc
or tr -dc "abc\n"
# seq 1 10 > f1
tr '\n' ' ' < f1 > f2
tr ' ' '\n' < f2

# 文件小写转为大写
tr 'a-z' 'A-Z' < /etc/issue
```

### 4. 管道 ｜

- 使用 ｜连接多个命令
- 命令1 ｜ 命令2 ｜...
  - 将命令1的stanout发送给命令2的stdin ...
  - stderr默认不能通过管道传递

```SHELL
ls | tr 'a-z' 'A-Z'
```

## 3. 文件权限

### 1. 文件类型

```SHELL
lrwxrwxrwx.		# 链接文件l
-....					# 文件
d....					# 目录文件
s....					# socket 套接字
b....					# 块文件
c....					# 字符文件
```

```SHELL
-rw-r--r--.   1      root root   14   Jul 30 16:24  1.cfg
权限				引用次数    属主 属组   大小	   mtime时间   文件名
```

### 2. 更改属主、组

- chown：change ower

#### 1. 用法

`Usage: chown [OPTION]... [OWNER][:[GROUP]] FILE…
  or:  chown [OPTION]... --reference=RFILE FILE…`

#### 2. 参数

1. -R：递归更改属主
2. `--reference=源文件`：指定组或主和源文件一样

```SHELL
chown 属主 filename
chown 属主:属组 filename    # :和. 都可以
chown 属主.属组t filename
chown :属组 filename       # 只改变属组
chown -R henry test       # 递归更改属主，不使用-R子文件属主不变
```

```SHELL
# 修改组
chgrp henry fielname
# 指定filename1的组别和filename一样
chgrp --reference=filename1 filename 
```

### 3. 权限操作

#### 1. drwxr-xr-x

1. 第一位：代表文件类型
2. 三位为一组：属主(u)、属组(g)、其他的权限(o)
3. rwx：读、写、执行
4. root用户不受权限控制

```SHELL
# 设置不覆盖原文件
set -C
> a.txt
# 允许覆盖原文件
set +C
> a.txt
```

```SHELL
# 查看当前登录的用户
[root@localhost ~]# whoami
root
[root@localhost ~]# who am i
root     pts/3        2019-07-31 11:01 (172.16.44.1)
# 查看当前所有用户正在执行的命令
[root@localhost ~]# w
```

#### 2. 更改权限

1. 文件
   - r / 4：可以查看
   - w / 2：可以写
   - x / 1：可以执行

2. 目录的权限：一般是r和x一起存在
   - r / 4：可以使用ls查看
   - w / 2：可以创建或删除文件
   - x / 1：可以 cd 进文件夹，如果没有x权限w权限不生效，r生效只能查看哪些文件**权限看不到**

```SHELL
# 更改文件权限
chmod o-r filename   # 给其他去掉r权限
chmod +x filename    # 给所有加上x权限
chmod ug-x filename  # 给u和g去掉x权限
# 更改目录权限
chmod o-x dirname
chmod o+w dirname
chmod o=w dirname    # 其他权限只有
# 使用数字更改权限
chmod 644 文件名
chmod 755 目录
- 建议：不要给777权限
```

```SHELL
# 执行a.py文件
echo '#!/usr/bin/python' > a.py
echo '#coding:utf-8' >> a.py
echo 'print(123)' >> a.py
chmod +x a.py
./a.py
# 或者
chmod -x a.py
python a.py
```

#### 3. 特殊权限chattr

**参数**：

1. i：不能修改、删除、改名
2. a：只能追加内容

```SHELL
# 设置 i 属性
chattr +i a.txt
# 查看特殊权限
lsattr a.txt
```

## 4. 文本操作

### 1. cat

参数：

1. -E：在每行结束处显示"$"
2. -n： 对输出的所有行编号
3. -b：对非空输出行编号
4. -s：折叠空行为一行

```SHELL
cat -E /etc/passwd
cat -n /etc/passwd
cat -b /etc/passwd
cat -sn /etc/passwd
```

### 2. tac

- 倒叙显示文件内容

```SHELL
tac /etc/passwd
```

### 3. less

- 分屏显示，空格一屏，回车一行
- /搜索， n：先后搜索 N：向前搜索
- q：退出

```SHELL
less /etc/passwd
# 搜索
/root 回车
```

### 4. more

- 分屏显示(百分比)，空格一屏，回车一行
- -d：显示翻页和退出信息
- 输出完自动退出，也可使用q提前退出

```SHELL
more -d /etc/passwd
```

### 5. head

- 显示前多少行，默认显示10行
- -n：指定显示前 n 行

```SHELL
head /etc/passwd
# 显示前 3 行
head -3 /etc/passwd
```

### 6. tail

- 显示后多少行，默认后10行
- -n：指定显示后 n 行
- -f：追踪显示文件新加入的内容，一般用于查看日志
- tailf：相当于 tail -f

```SHELL
# 文件更改时访问
tail /etc/passwd
# 显示后 3 行
tail -3 /etc/passwd
```

```SHELL
# 实时访问文件
tailf /etc/passwd
```

### 7. cut

- 抽取文件

#### 参数

1. -d：指定切割符
2. -f：指定显示指定列的数据(3中方法可以混用)
3. -c：按照字符切割

```SHELL
cut -d: -f3 /etc/passwd
cut -d: -f3,5,6 /etc/passwd
cut -d: -f3-6 /etc/passwd
cut -d: -f3-5,7,9 /etc/passwd
# 按字符切割
cut -c2-5 /etc/passwd
```

### 8. paste

- -d：指定合并的符号
- -s：把所有行合并一行显示

```SHELL
# 合并 b 和 d
paste -d: b d
# 默认是tab
paste b d
```

## 5. 分析文本

### 1. wc (word count)

- 空格和换行都认为是单词结束

#### 参数

1. -l：行数
2. -w：单词个数
3. -c：字节数
4. -m：字符数
5. -L：文件中最长行长度

```SHELL
[root@localhost ~]# wc /etc/passwd
  43   86  2238 /etc/passwd
 行数  字数 字节数    文件
 wc -l /etc/passwds
```

### 2. sort

- 把文本显示在stdout中，不该变原文件

#### 参数

1. 默认按照字母排序
2. -n：按照数字排序
3. -r：倒叙
4. -R：随机排
5. -f：忽略大小写

```SHELL
sort b
sort -n b
sort -r b
sort -R b
# 先切割，根据第 3 列排序
sort -t: -k3 /etc/passwd
```

### 3. uniq

- 从输入中删除**前后相接**的重复行

#### 参数

1. -c：显示重复次数
2. -d：只显示重复行
3. -u：只显示不重复行

```SHELL
echo '1' >> b
echo '1' >> b
echo '2' >> b
echo '1' >> b
echo '1' >> b
uniq b
uniq -c b
uniq -d b
uniq -u b
```

```SHELL
# 应用
sort -n b | uniq -c
w|sort|cut -d\  -f1|uniq -c
ss -tnp| cut -d: -f2|tr -s " "| cut -d" " -f2 |sort -n｜ uniq -c
```

###  4. diff

- 对比两个文件

```SHELL
diff a.txt b.txt
```













