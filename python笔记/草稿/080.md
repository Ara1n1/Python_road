# RESTful

## 1. REST

Respresentation State Transfer

## 2. RESTful API设计

1. api与用户的通信协议，推荐使用https
2. 域名
   1. `https://api.example.com `尽量将api部署在专用域名(会存在跨域问题)
   2. `https://example.org/api/ `api很简单
3. 版本
   - url 如：`https://api.example.com/v1/`
4. 请求头  跨域时，引发发送多次请求
5. 路径，网络上任何东西都是资源，均使用名词表示(可复数)
6. method
   1. GET 获取服务器上的资源，返回资源列表或一个资源
   2. POST 新建资源，返回新建资源
   3. PUT 在服务器更新资源(客户端提供改变后的完整资源)，返回更改后的资源
   4. PATCH 在服务器更新资源(更改某些数据)
   5. DELETE 删除资源，返回空/提示
7. 过滤，通过url上传参形式
   1. `https://api.example.com/v1/zoos?limit=10`
   2. `https://api.example.com/v1/zoos?offset=10`
   3. ...
8. 状态码
   1. 200 ok
   2. 201 created  [POST/PUT/PATCH]：用户新建或修改数据成功
   3. 201 Accepted 表示需要排队，异步
   4. 204 No content [DELETE]：用户删除数据成功
   5. 错误处理，状态码4xx，应返回错误信息，error当作key
9. Hypermedia API 返回关联的数据时，尽量返回url地址

`www.ruanyifeng.com/blog/2014/05/restful_api.html`



- jsonresponse可以序列化datetime类型

```python
JsonResponse(list(), safe=False, json_dumps_params={'ensure_ascill': False})
```

- django提供的序列化器

```python
from django.core import serializers
```

## 3. 使用rest_framwork流程

### 1. 注册rest_framework app 

- **不使用序列化器时**，多对多关系对应多个值时，**会分别为关联值构造不同的字典**
- 结构：**[{},{}...]**
- rest_framework的**Response()不能序列化对象**

```python
from rest_framework.views import APIView
from rest_framework.response import Response

class BookListView(APIView):
  	def get(self, request, *args, **kwargs):
      	all_book = models.Book.object.all().values('id', 'title', 'auther__name')
        return Response(all_book)
```

### 2. 使用序列化器精简数据

- 多对多关系使用**authors = serializers.SerializerMethodField(read_only=True)**方法
- 需要实现**get_authors**方法

```python
# serializer.py文件，app目录下
from rest_framework import serializers
from app01 import models

class Publisherserializer(serializers.Serializer):
  	name = serializers.CharField()

class AuthorSerializer(serializers.Serializer):
  	id = serializers.IntegeField()
  	name = serializers.CharField()
   
class BookSerializer(serializers.Serializer):
  	title = serializers.CharField()
    price = serializers.DecimalField(max_digits=6, decimal_places=2)
    pub_date = serializers.DateTimeField()
    # 外键
    # pub_id = serializers.IntegeField()
    pub = Publisherserializer(required=False, read_only=True)
    # 多对多，需要实现get_authors 方法
    authors = serializers.SerializerMethodField(read_only=True)
    
    # post请求
    post_pub = serializers.CharField(write_only=True)
    post_authors = serializers.ListField(write_only=True)
    
    def get_authors(self, obj):
      	ser_obj = AuthorSerializer(obj.authors.all(), many=True)
      	return ser_obj.data
    # post操作调用
    def create(self, validated_data):
      	book = models.Book.objects.create(
            title=validated_data['title'],
            price=validated_data['price'],
            pub_date=validated_data['pub_date'],
            pub_id=validated_data['post_pub'],
        	)
        book.authors.set(validated_data['post_author'],)
        return book
    # put操作调用
    def update(self, instance, validated_data):
      	instance.title=validated_data.get('title', instance.title)
        instance.price=validated_dataget('price', instance.price)
        instance.pub_date=validated_dataget('pub_date', instance.pub_date)
        instance.pub_id=validated_dataget('pub_id', instance.pub_id)
        instance.save()
        instance.authors.set(validated_data.get('post_author', instance.authors.all()),)
        return instance   	
```

### 3. 导入view.py中使用

1. 使用序列化器时，默认情况下一次只能序列化**一个对象**，如果是对象列表则需要使用**many=True**参数
2. 使用序列化器后，WSGI封装的**request**此时为 **request._request**
3. 序列化后的对象，**obj.data**即为从数据库中读取的数据，tpye为**ordereddict的list**
   - [OrderedDict([(), ()…]), OrderedDict([(), ()…]), … ]

```python
# app的views.py
from rest_framework.response import Response
from rest_framework.views import APIView
from app01 import models
from app01.serializer import BookSerializer


class BookListView(APIView):
	book_obj = {}

    def get(self, request, pk=None, *args, **kwargs):
        if not pk:
          	all_book = models.Book.objects.all()
        else:
            all_book = models.Book.objects.filter(pk=pk)
            self.book_obj['obj'] = all_book.first()
            
        ser_obj = BookSerializer(all_book, many=True)
        # print(ser_obj.data, type(ser_obj.data))
        # .data获取序列化结果
        return Response(ser_obj.data)

    def post(self, request, *args, **kwargs):
      	# 必须使用application/x-www-form-urlencoded，表单数据
      	print(request.POST)
        # 使用必须使用application/json, 获取的是dict类型，request发生了变化
        print(request.data, type(request.data))
        # print(request.data)
        ser_obj = BookSerializer(data=request.data)
        if ser_obj.is_valid():
            ser_obj.save()
            return Response(ser_obj.data)
        return Response(ser_obj.errors)

    def put(self, request, *args, **kwargs):
        obj = self.book_obj.pop('obj', None)
        if not obj:
          	return Response('更新数据不存在')

        ser_obj = BookSerializer(instance=obj, data=request.data)
        if ser_obj.is_valid():
            ser_obj.save()
            return Response(ser_obj.data)
        return Response(ser_obj.errors)

    def delete(self, requset, pk, *args, **kwargs):
        obj = models.Book.objects.filter(pk=pk)
        if obj:
            obj.delete()
            return Response({'msg': '删除成功'})
         return Response({'msg': '数据不存在'})
```











