## websocket

1.  TCP/UDP，HTTP
2.  HTTP：无状态的短链接

需求：类似web 微信的一个即时通讯工具

1.  做前端

2.  建立webserver   django / flask

3.  制作聊天功能

    -   A to B message
    -   A to server Find B to B Message：find b失败

    A:{to:B,  char:'come on baby', from: A}

    -   A Http B Http
    -   server MessageBox存放 B Message

    Server:[{to:B,  char:'come on baby', from: A}, ]

    -   B Http to sever，from MessageBox 

    B ->MessageBox -> key=to=B -> chat

    -   B recv Message

    **轮询**：不能保证数据的实时性

    ​		A、B client：无限循环和服务器对话，有 xx 消息吗？

    **长轮询**：

    ​		A、B client：client 发起请求至 server，等待15s(默认http超时时间) --> 等待消息时间

    ​		-->主动断开连接

    ​		-->收到消息主动返回

4.  断开连接

长链接：

-   server端给客户端发送指令
-   client端做出响应

长链接特性：

-   A、B client --> server 建立连接并保持连接不断开
-   A to B --> server 消息转发 -->B 建立连接的情况下，可以及时准确收到消息
-   客户端和服务器保持永久性连接
-   除非有一方主动发起断开
-   消息转发

## 2. Websocket 

-   长连接
-   web + socket
-   Flask + Websocket 模块 + gevent-websocket

```python
# 下载 gevent-websocket，Websocket
from flask import Flask
# 请求处理 WSGI 处理 HTTP 请求，WebSocketHandler处理socket请求
from geventwebsocket.hander import WebSocketHandler
# 替换flask的 Werkzueg
from geventwebsocket.server import WSGIServer
# 语法提示
from geventwebsocket.websocket import WebSocket

app = Flask(__name__)

@app.route('/ws')
def ichat():
    request.environ
    ws_socket = request.environ.get('wsgi.websocket') # type:WebSocket
    try:   
        while True:
            msg = ws_socket.receive()
            print(msg)
            ws_socket.send(b'xxx')
    except:pass
    # return '200 ok!'


if __name__ == '__main__':
    # handler_class=WSGIhandler（not sure），只支持http请求
    http_server = WSGIServer(('0.0.0.0', 9527), app, handler_class=WebSocketHandler)
    http_server.server_forever()
```

### websocket的状态码

-   0：连接创建失败，
-   1：当前link激活，处于可用状态
-   2：客户端主动断开连接，看不到其状态码
-   3：服务器主动发起断开

```js
<script type='application/javascript'>
	var ws = new WebSocket('ws://127.0.0.1:9527/ws')
	ws.onmessage = function(messageEvent){
        console.log(messageEvent.data);
    }
</script>
// ws.close
```

## 3. websocket广播

```python
# 下载 gevent-websocket，Websocket
from flask import Flask
# 请求处理 WSGI 处理 HTTP 请求，WebSocketHandler处理socket请求
from geventwebsocket.hander import WebSocketHandler
# 替换flask的 Werkzueg
from geventwebsocket.server import WSGIServer
# 语法提示
from geventwebsocket.websocket import WebSocket

app = Flask(__name__)
socket_li = []
@app.route('/ws')
def ichat():
    request.environ
    ws_socket = request.environ.get('wsgi.websocket') # type:WebSocket
    socket_li.append(we_socket)
    while True:
        msg = ws_socket.receive()
        print(msg)
        for u in socke_li:
            if u == ws: continue
            try:
        		u.send(b'xxx')
            except:pass


    # return '200 ok!'


if __name__ == '__main__':
    # handler_class=WSGIhandler（not sure），只支持http请求
    http_server = WSGIServer(('0.0.0.0', 9527), app, handler_class=WebSocketHandler)
    http_server.server_forever()
```

-   

```html
<input type='text' id='content'>
<button onclick='send_message()'>发送</button>
<div id='content_list'>
    
</div>
<script type='application/javascript'>
	var ws = new WebSocket('ws://127.0.0.1:9527/ws')
	ws.onmessage = function(messageEvent){
        console.log(messageEvent.data);
    };
    function send_message(){
        
    }
</script>
```

基于websocket实现群聊

1.  建立websocket 服务 + Flask web 框架 + Gevent-WebSocket
2.  requst.environ.get('wsgi.websocket')获取链接，并保存到服务器中
3.  基于长连接socket 接收用户传递的消息
4.  将消息转发给其他用户

基于javascirpt 实现websocket客户端

```javascript
var ws = new WebSocket('ws://ip:port/路径')
// ws.onmessage 当ws客户端收到消息时执行回调函数
// ws.onopen 当ws客户端建立完成连接时， status == 1 时执行
// ws.onclose 当ws客户端关闭中后关闭，执行的回调函数，status 2 或 3
// ws.onerror 当ws客户端出现错误时
ws.onmessage = func(messageEvent){
    
}
```

## 单人聊天

1.  服务器保存的连接方式变化，以dict形式储存
    -   存储结构：{uid: websocket连接, user1:websocket}
2.  消息发送时，receiver， data = {'sender':发送方, 'receiver':接收发, data:数据}
    -   从data中找到接收方的key
    -   去存储结构中找到 key 对应的websocket连接
3.  websocket.send(data).  socket传输， bytes类型

```python
ws.send(JSON.stringify(dict))
```







