## 1. 路由

### 1. 装饰器装饰多个函数

1. 自定义装饰器最终会出现多个 inner 函数最终为 endpoint，flask中通过endpoint查找view
2. 基于functools 修改 `__name__`
3. 添加endpoint参数

```python
@app.route('/a', endpoint='end_a')
@warpper
def a():
    pass
  
@app.route('/b', endpoint='end_b')
@warpper
def b():
    pass
  
@app.route('/', endpoint='home')
@warpper
def home():
    pass
```

- endpoint值必须唯一

### 2. route参数(5)

#### 1. methods=[]/()

- 请求方式不区分大小写

```python
@app.route(rule, methods=['get', 'POST', 'options'])
```

- getatter() or ('GET', )
- set(item.upper() for item in methods)

#### 2. endpoint=None

- 解决装饰器不能装饰多个函数的问题
- 路由地址和endpoint的mapping)
- 路由地址和视图之间mapping
- 默认是视图函数名

```python
@app.route('/', endpoint=None)
def home():
    return 'ok!'
```

#### 3. defaults={'count': 20}

- 默认20，用于分页

```python
from flask import Flask
url_for('end_a')
url_for('home')
# {'end_a':'/a', 'home': '/'}
```

```python
@app.route(rule, endpoint=None, defaults={'count':20})
def home(count):
    count = request.args.get('count', count)
    return f'200 ok!{count}'
```

#### 4. strict_slashes=False

- 是否严格遵循地址匹配

```python
@app.route(rule, endpoint=None, strict_slashes=True)
def home():
    return f'200 ok!{count}'
```

#### 5. redirect_to='/'

- 永久重定向，状态码，308/301

```python
@app.route(rule, endpoint=None, redirect_to='/')
```

### 3. 动态参数路由

- str：可以收一切，默认是 str 类型
- rule：`/ge t_music/<filename>`， `/home/<int:page>`， `/home/<ty>_<page>_<id>`，分页、获取文件、解决分类，解决正则路由
- send_file()：需要限定文件目录

```python
@app.route('/home/<int:page>', endpoint='home',)
def home(page):
    print(type(page))
    return '200 ok!'
  
@app.route('/home/<page>_<ty>_...', endpoint='home',)
def home(page, ty, ...):
    pass
  
@app.route('/home/<filename>', endpoint='home',)
def home(filename):
    return send_file(f'media/{filename}')
```

## 2. Flask中的配置

### 1. 初始化配置

#### 1. template_folder=''

- 指定模板存放路径，默认时templates

```python
app = Flask(__name__,  template_folder='templates')
```

#### 2. staic_folder='static'

- 锁定访问目录，静态文件存放目录，默认：static

```python
app = Flask(__name__, static_folder='img', static_url_path='/static')
# http://127.0.0.1:5000/static/1.jpeg
```

#### 3. static_url_path='/static'

- 静态文件访问路径，默认`/staic_folder`
- 自动拼接 host

```python
<img src='访问地址'>
<img src='static/1.jpg'>
```

- static_host=None：其他主机

- instance_path：多app

### 2. 实例配置(app配置)

#### 1. default_config

- default_config = {} ：默认配置
- 'TESTING'：False，日志级别为Debug
- ''：31days
- JSONIFY_MIMETYPE='application/json'

```python
# 开启 debug 模式
app.debug = True
# 使用session
app.secret_key = 'R&w34hr*&%^R7ysdjh9qw78r^*&A%863'
# session名称
app.session_cookie_name = 'ah'
# session生命周期，20s过期为 None
app.permanent_session_lifetime = 20
# respone头中content-type:xxx
app.config['JSONIFY_MIMETYPE']='xxx'
```

#### 2. settings.py

```python
import hashlib

class DubugConfig(object):
    DEBUG = True
    SECRET_KEY = '#$%^&fguyhij&^$EHBksdj`109u23'
    PERMANENT_SESSION_LIFETIME = 3600
    SESSION_COOKIE_NAME = 'ah'

class TestConfig(object):
    TESTING = True
    SECRET_KEY = hashlib.md5(f'{time.time()}#$%^&124:"hfag(&sfdgh3ir;dfguyhij&^$EHBksdj`109u23{time.time()}'.encode('utf-8')).hexdigest()
	PERMANENT_SESSION_LIFETIME = 360000
    SESSION_COOKIE_NAME = '$%^&124:"hfag('
```

#### 3. 配置生效

```python
from settings.py import DubugConfig,TestConfig
app.config.from_object(DubugConfig)
app.config.from_object(TestConfig)
```

## 3. Blueprint

- 不能被run的flask实例，不存在config

```python
from flask import Blueprint

bp = Blueprint('app01', __name__,url_prefix='/car')

@bp.route('/user')
def user():
    return 'I am app01!'
```

```python
from app01 import bp
app.register_blueprint(bp)
```

## 4. 特殊装饰器

- requset校验没过时，绕过view 执行全部after_request
- 只要有响应返回，af全部执行

### 1. @app.before_request

- 在请求进入视图函数之前，作出处理

```python
@app.before_reqeust
def be1():
    print('i am be1')
    
@app.before_reqeust
def be2():
    print('i am be2')
```

### 2. @app.after_request

- 在响应返回客户端之前，结束view之后

```python
@app.after_request
def af1(res):
    print('i am in af1')
    return res

@app.after_request
def af2(res):
    print('i am in afp2')
    return res
```

### 3. @app.errorhandler(404)

- 监听状态码只能是 4xx和5xx
- 需要接受错误信息

```python
@app.errorhandler(404)
def error404(error_message):
    print(error_message)
    return 'xxx' 		# 5种类型
```

