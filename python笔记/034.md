##今日内容

- https：加证书，需要购买
- 四核八线程：
  - 每个核心被虚拟成两个核心，可以同时执行8个线程。
  - 如果是计算复杂数据，会转换到四核
- 进程里面无法进行input：所有print都是向文件里写数据

什么是io操作：

- i input 向内存中输入 input，read，recv， recvfrom， accept， connect， close
- output 从内存中输出 print，write，send，sendto， accept， connect， close

ipc进程间通信：

- 管道和队列
- 第三方提供：redis，memcache，kafka，rabbitmq
- 消息中间件(消息转发)



## 9.3 

### 1. 生产者消费者模型

#### 1.1 程序的解藕

- 把写在一起打的功能分开成多个小的功能处理
  - 修改和复用，增加可读性
  - 计算速度有差异，执行效率最大化，节省进程

- 生产者：生产数据
- 消费者：处理数据

![生产者消费者模型](/Users/henry/Documents/截图/Py截图/生产者消费者模型.jpg)

#### 1.2 进程和生产者或消费者

1. 一个进程就是一个生产者/消费者
2. 生产者和消费者之间的容器就是队列(队列有大小，控制内存消耗)

```python
# 生产者消费者模型示例
import time
import random
from multiprocessing import Process, Queue

def producer(q, name, food):
    for i in range(10):
        time.sleep(random.random())
        fd = '%s%s' % (food, i)
        q.put(fd)
        print('%s生产了一个%s' % (name, food))

def consumer(q, name):
    while True:
        food = q.get()
        if not food:
            q.put(None)
            break
        time.sleep(random.randint(1, 3))
        print('%s吃了%s' % (name, food))

def cp(num1, num2):
    q = Queue(10)
    p_l = []
    for i in range(num1):
        p = Process(target=producer, args=(q, 'henry', 'food'))
        p.start()
        p_l.append(p)
    for i in range(num2):
        c = Process(target=consumer, args=(q, 'echo%s' % (i+1,)))
        c.start()
    for i in p_l:
        i.join()
    q.put(None)

if __name__ == '__main__':
    cp(1, 4)
```

```python
# 示例2
import re
import json
import requests

def getPage(q, url):
    response=requests.get(url)
    q.put(response.text)

def parsePage(s):
    while True:
      msg = q.get()
      if not msg:break
    	com=re.compile('<div class="item">.*?<div class="pic">.*?<em .*?>(?P<id>\d+).*?<span class="title">(?P<title>.*?)</span>'
                   '.*?<span class="rating_num" .*?>(?P<rating_num>.*?)</span>.*?<span>(?P<comment_num>.*?)评价</span>',re.S)
      ret=com.finditer(s)
      for i in ret:
          yield {
              "id":i.group("id"),
              "title":i.group("title"),
              "rating_num":i.group("rating_num"),
              "comment_num":i.group("comment_num"),
          }

if __name__ == '__main__':
   url='https://movie.douban.com/top250?start=%s&filter='%num
   count=0
   for i in range(10):
			
      count+=25
```

#### 1.3 joinablequeue

- **q.join()**：阻塞，知道队列中所有内容被取走且task_done

![joinable_queue](/Users/henry/Documents/截图/Py截图/joinable_queue.png)

![joinable逻辑](/Users/henry/Documents/截图/Py截图/joinable逻辑.png)

```python
# joinable实现生产者、消费者模型
import time
import random
from multiprocessing import Process,JoinableQueue

def producer(q, name, food):
  for i in range(10):
    time.sleep(random.random())
    fd = '%s%s'%(food,i)
    print('%s生产了一个%s'%(name, food))
  q.join()

def consumer(q, name, food):
  while True:
    food = q.get()
    if not food:
      q.put(None)
      break
    time.sleep(random.randint(1, 3))
    print('%s吃了%s'%(name, food))
    q.task_done()
 
if __name__ = '__main__':
  jq = JoinableQueue()
  p = Processor(target=producer, args=(jq, 'henry', 'food'))
  p.start()
  
```

### 2. 进程间数据共享

- 与数据共享相关：**Manager模块**(Manager().list(), Manager().Queue)
- multiprocessing 中有一个manager类
- 封装了所有和进程相关的数据共享、数据传递
- 但是对于dict、list这类进行数据操作时，会产生数据不安全
- m = Manager()也可以使用with Manager() as m:

```python
from mutliprocessing import Manager,
def func(dic, lock):
  with lock:
		dic['count'] -= 1

if __name__ = '__main__':
  # m = Manager()
  lock = Lock
  with Manager() as m:
    l = Lock()
    dic = m.dict({'count': 100})    							# 共享的dict
    p_l = []
    for i in range(100):
      p = Process(target=func, args=(dic,lock))
      p.start()
      p_l.append(p)
    for p in p_l:p.join()
    print(dic)
```

### 3. 线程

#### 3.1垃圾回收机制

1. **cpython**解释器不能实现多线程利用多核
2. 垃圾回收机制(gc)：**引用计数** + **分代回收**
   - 专门有一条线程完成垃圾回收机制，对每一个在程序中的变量统计引用计数

#### 3.2 GIL锁

**GIL**：**全局解释器锁**

1. 保证了整个python程序中，只能有一个线程被CPU执行
   - 导致了py程序不能并行
   - 使用多线程并不影响高IO型操作，只会对高计算型程序有效率的影响
   - 遇到高计算：多进程+多线程，分布式
2. 原因：**cpython**解释器中特殊的垃圾回收机制
3. cpython、pypy，jpython(先翻译为java字节码，在java上执行)、iron python

#### 3.3 遇到IO操作的时候

1. 5-6亿条cpu指令
2. 5-6cpu指令 == 一句python代码
3. 几千万条python代码

#### 3.4 web框架几乎都是多线程

- 利用IO操作，类似多道系统



### 3. 初时线程(重点)

- cpython解释器当中的线程问题

### 4. python操作线程(重点)