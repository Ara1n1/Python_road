```python
# CBV
from flask import views

app.add_url_rule('/login', 
                  # endpoint = 'my_login',
                  view_func = Login.as_view(name='login_login'),
                 )

@app.before_request
def is_login():
  	return 1

@app.after_request
def login_ok(res):
  	return res

class Login(views.MethodView):
  	# decorators = []
  	def get(self):
      	return 'here is get.'
    def post(self):
      	pass
```

-   view_func=Login.as_view(...) , 视图函数CBV 由as_view完成
-   methods：默认是类对应的方法
-   view.view_class = cls：在view函数中增加属性
-   `view.__name__=name`：logilogin
-   `view.__doc__` = `cls.__doc__`：调用或赋值
-   `view_func.__name__='login_login'`

1. views.MethodView：继承让当前class可以成为视图类
2. 定义视图类支持的请求方式
3. 添加路由，as_view(name='login_login')。name就是endpoint
4. 可以添加类变量：methods  / decorator = ['is_login']

## 总结

### 1. flask启动

```python
pip install flask
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
		return ''  					# httpresponse
# 监听地址和端口
app.run('0.0.0.0', 5000)
# werkzeug调用run_simple
# wsgi处理请求头(网关接口)
# wsgi处理后的数据，environment。
```

## response

```python
1. ''
2. render_template('')  # 默认存放路径 templates，打开模版并替换，依赖包 MarkupSafe中的 Markup 发送给浏览器
3. redirect('/')				# 重定向，在响应头中加入 Location: /
4. send_file(file)			# 打开文件并返回文件内容，自动识别文件类型并加入content-type:文件类型
5. jsonify()						# 返回标准格式的 json 字符串，Content-Type:application/json
# flask 1.1.1 中，直接返回 dict，本质是在运行 jsonify
```

## request

- 请求上下文的存放机制
- 关键异常：KeyError
- from flask import request

```python
request.form						# 获取FormData中的数据，to_dict()，继承了dict（KeyError）
request.args						# 获取 url 中数据
request.json						# 请求头中 content-type:application/json 存放
request.data						# content-type:没有Form，FormData都存放 b''原始信息
request.method
request.cookies
request.headers						# 请求头
request.path						# 请求地址
request.url							# 完成地址
request.host						# 127.0.0.1:5000
request.host_url					# http://127.0.0.1:5000/login
requstt.values
```

## session

- 请求上下文的存放机制
- 交由客户端保管机制，保管一串儿加密的字符串
- from flask import session

```python
app.secret_key = 'hasdhi$%^&*wqjfdshis'
app.config['SECRET_KEY'] = 'syadfi#$%^&*wahuifbpH'
session['key'] = 'value'
```

## route

```python
@app.route(rule, methods, endpoint, strict_slashes, redirect_to, defaults)
# rule：mapping 名称对应路由 url_for()反向解析，url_for(endpoint)
# method：允许请求方式
# redirect_to：301， 308
# strict_slashes：默认True
# defaults：默认参数


app.add_url_rule(rule, 
                 view_func,		# 给指定视图函数添加路由
                )
# 动态参数路由
'/get_file/<filename>'
def get_file(filename):
  	pass
```

## 初始化

```python
template_folder 
static_folder
static_url_path							# 静态文件访问路径
```

## appconfig

```python
class DebugConfig(object):
  	DEBUG = True

app.config.form_object(DebugConfig)
```

## 蓝图

- app的功能隔离

```python
from flask import Blueprint
# config在run时加载
# url_prefix：
bp = Blueprint('bp', __name__, url_prefix)
@bp.route('/mybp', endpoint='xx')
def index():
  	pass
# 或 bp.add_url_rule()
# 访问当前蓝图中的装饰器
@bp.before_request
@bp.after_request
@bp.errorhandler(Http错误码)



url_for('蓝图.endpoint')
url_for('bp.xx')

app.register_blueprint(bp)
```

## 特殊装饰器

```python
@app.before_request
@app.after_request
# 重定义错误信息
@app.errorhandler(Http错误码)
```

## CBV

```python
from flask import views

class Index(views.MethodView):
  	def get(self, *args, **kwargs):
      	pass
    ...
    
app.add_url_rule('/index', endpoint=None, view_func=Login.as_views(name='login')
```

## redies

```python
# 总共 16 个库，0-15，用来数据隔离
select 8					# 切换 8 号库，默认 0 号库
set key value			# 设置一个健值对，哈希存储结构{key:value}
keys pattern			# 查询当前数据库中所有的key,如keys * 查询当前数据库中所有key
		 a*						# 查询以 a开头
  	 *n*					# 包含 n
...
get key						# 查询 key 对应的 value
# 多次设置同一个key 会被覆盖
```

- python操作redis

```python
from redis import Redis
redis_cli = Redis(port=6379, db=6)
redis_cli.set('name', 'echo')
```

## Flask-session

- 三方组件：pip install flask-session
- app.config最终在 app.default_config中
- settings.py中的DebugConfig中，不是大写英文的一律丢弃不管

```python
from flask import Flask, request, session
from flask_session import Session

app = Flask(__name__)
# app.secret_key = '%^&*JBHJ%$*lkdsj'
app.config['SESSION_TYPE'] = 'redis'
app.config['SESSION_REDIS'] = Redis('127.0.0.1', 6379, db=10)
Session(app)

@app.route('/sets')
def sets():
  	session['key'] = 'henry'
  	return 'set ok!'
 
@app.route('/gets')
def gets():
  	return session.get('key')

if __name__ == '__main__':
		app.run()

```

```python
app.session_interface			# flask 利用session_interface，选择session存放位置和机制
# session_interface = self._get_interface(app)
app.config['SESSION_TYPE'] = 'redis'
app.config['SESSION_REDIS'] = Redis(host='192.168.12.9', 6379, db=10)

# redis通过pickle序列化，secret_key只有原生的config需要
```

## Flask上下文

### 1. 偏函数

-   flask中的requst 和session

```python
from functools import partial

def ab(a, b):
    return a+b

new_func = partial(ab, 1, 3)

print(new_func())
```

### 2. 线程安全

```python
import time
# local：{线程号1:{变量名:值},...}
from threading import local

class Foo(local):
    num = 0
foo = Foo()

def addi(i):
    foo.num = i
    time.sleep(0.2) 		# 相当于 i/o 操作
   	print(foo.num)

from threading import Thread
for i in range(20):
    th = Thread(target=addi, args=(i,))
    th.strat()    
```

### 3. 

```python
# werkzeug 搭建app
from werkzeug.wrappers import Response, Request
from werkzeug.serving import run_simple

@Request.application
def app(req):
    print(req, req.method)
    return Response('200 ok')

run_simple('0.0.0.0', 5000, app)


# environ：wsgi 处理requset后的结果，请求原始信息
# 对象相当于dict
__slots__ = ('__stroage__', '__ident_func__')
```



