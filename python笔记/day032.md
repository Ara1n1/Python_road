##回顾

1. 操作系统
   - 调度进程先后执行顺序，控制执行的时间等等
   - 资源分配
2. 进程
   - 进程和程序之间区别
     - 进程就是运行中的程序
   - 进程调度：os完成
   - 三状态图
     - —>就绪-system call <—>时间片到了-运行—> io —>阻塞-io结束—>就绪
     - 阻塞：影响了程序运行的效率
3. 概念
   - 同步异步
     - 同步：调用一个方法，要等待这个方法结束
     - 异步：调用一个方法，不等待这个方法结束，不关心这个方法做了什么
   - 阻塞非阻塞
     - 阻塞：cpu不工作
     - 非阻塞：cpu工作
   - 并发并行
     - 并发：多个程序共同使用一个cpu，轮流使用
     - 并行：多个程序，多个cpu，一个cpu上运行一个程序
       - 在一个时间点上，多个程序同时在多个cpu上运行

## 今日内容

- 线程
- pyhton中操作进程
  - multiprocessing
    - process类 完成进程开启、销毁、基础操作
    - Lock 锁的概念
      - 数据安全问题

## 9.2 线程

### 1. 线程

####1.1 分别做多件事

   - 如果是两个程序分别做两件事
     - 起两个进程
   - 如果是一个程序，要分别做两件事
     - 视频软件：下载电影1，电影2，电影3

####1.2 **进程**

1. 顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。

2. 进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的**抽象概念**之一。操作系统的其他所有内容都是围绕进程的概念展开的。

   

   **PS**：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。

3. **进程概念**

   - 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括**文本区域**（text region）、**数据区域**（data region）和**堆栈**（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
   - 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。
     进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。

4. 特点

   - 是计算机中最小的**资源分配单位**，**数据隔离**。
   - 创建进程时间**开销大**
   - 销毁进程时间开销大
   - 进程之间切换时间开销大

####1.3 线程

   - 线程是进程中的一部分，不能脱离进程存在

   - 任何进程中至少有一个线程，只负责执行代码，不负责存储共享的数据，也不负责资源分配

   - **进程**负责数据隔离
   - **线程**负责执行代码，共享**全局资源**
   - 进程是计算机中最小资源分配单位
   - 线程是计算机中能被cpu调度的最小单位

####1.4 开销

   - 线程的创建和销毁
     - 需要一些开销(一个存储局部变量的数据结构，记录状态)
     - 创建、销毁、切换**开销**远**远小于**进程
   - python中的线程比较特殊，所以进程也有可能被用到
   - 进程：数据隔离、开销大  同时执行几段代码
   - 线程：数据共享、开销小  同时执行几段代码

### 2. 进程模块

#### 2.1 multiprocessing模块

- 基于process模块

```python
# 获取进程的pid, 父进程的id及ppid
import os
import time
print('start')
time.sleep(20)
print(os.getpid(),os.getppid(),'end')
```

#### 2.2 子进程和父进程

- pycharm中启动的所有py程序都是pycharm的子进程

```python
# 把func函数交给子进程执行
import os
import time
from multiprocessing import Process

def func():
  print('start', os.getpid())
  time.sleep(1)
  print('end', os.getpid())

if __name__ == '__main__':	  
  p = Process(target=func)				# 创建一个即将要执行的进程对象
  p.start()	                      # 开启一个进程，异步非阻塞
  p.join()												# 同步阻塞，直到子进程执行完毕
  print('main', os.getpid())			# 异步的程序，调用开启进程的方法，并不等待这个进程的开启
```

**创建子进程注意**

ps：_\_name__ 只有两种情况，文件名或双下划线main字符串

```python
# windows
只要导入就会执行p.start()，加上__mian__可以控制此类问题发生
创建新的子进程是执行import 父进程文件完成数据导入工作
# macos
创建新的子进程是copy父进程内存空间，完成数据导入工作（fork）
```

- windows中相当于把主进程中的文件又从头执行了一遍
- linux，macos不执行代码，直接执行调用的函数

- 父进程(主进程)

![父子进程](/Users/henry/Documents/截图/Py截图/父子进程.png)

- 进程之间不能进行数据共享
- 主进程需要等待子进程结束，主进程负责创建和回收子进程
- 子进程执行结束，父进程没有回收资源，即僵尸进程。
- 主进程结束逻辑：主进程代码结束、所有子进程结束、回收子进程资源、主进程结束
- 主进程怎么知道子进程结束？通过文件或网络进行进程通信

#### 2.3 join方法

- 把一个进程的结束事件封装成一个join方法
- 执行join方法效果，**阻塞**，直到子进程结束，就结束

```python
# 在多个子进程中使用join方法
from multiprocessing import Process

def send_mail(i):
    print('邮件已发送', i)
if __name__ == '__main__':
    li = []
    for i in range(10):
        p = Process(target=send_mail, args=(i,))  # args必须是元组，给子进程中的函数传参数
        p.start()
    li.append(p)
    for p in li: p.join()													# 阻塞，知道所有子进程执行完毕
    print('100封邮件已发送')
```









