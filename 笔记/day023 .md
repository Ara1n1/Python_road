## 今日内容

- 练习题
- 单例模式
- 日志模块（logging）
  - 公司服务器/线上环境：**异常处理**和**错误日志**(程序必须处理)
- 程序的目录结构

## 补充

1. 字符串格式化

```python
# %s ，只能是tuple
msg = '我是%s, 年龄%s' % ('alex', 19)
msg = '我是%(name)s, 年龄%(age)s' % {'name': 'alex', 'age': 19}
# format格式化
v1 = '我是{name}, 年龄{age}'.format(name = 'alex', age = 18)
v1 = '我是{name}, 年龄{age}'.format(** {'name': 'alex', 'age': 19})
v2 = '我是{0}, 年龄{1}'.format('alex', 18) 
v2 = '我是{0}, 年龄{1}'.format(*('alex', 18) )
```

2. 有序字典

```python
# __getitem__ set, del 
from collections import OrderdDict

info = OrderedDict()
info['k1'] = 123
info['k2'] = 456
```

3. 栈和队列

```python
class Stack(object):
  pass

class Queue(object):
  pass
```

4. 反射

```python
# 示例1
# if判断，构造dict，反射
```

```python
# 浏览器两类行为
# way1: 输入地址+回车
get....
# way2: 表单（输入框+按键）
post....

# 浏览器都会有get，post，dispatch方法
class View(object):
  def get(self):
    pass 
  def Post(self):
    pass
  def Dispatch(self):  # 请求第一步来这，在进行分发
    pass
```

```python
# 推荐使用性能较好
class Foo(object):
  def post(self):
    pass

# 方式1
if hasattr(obj, 'get'):
  getattr(obj, 'get')
# 方式2：推荐使用
v = getattr(obj, 'get', None)
print(v)
```

5. 循环过程中删除元素

```python
# 需要从后面删除
for循环是根据索引进行循环，删除元素后，后面要进行补位
```



## 内容详情

### 1. 单例模式

#### 1.1 单例

**场景**：**数据库**连接和数据库**连接池**（数据一致时）

**设计模式**：23种设计模式

```python
class Foo(object):
  pass 
# 每实例化一次，就创建一个新对象,内存地址 不一样
obj1 = Foo()
obj2 = Foo()
```

```python
# 单例模式，无论是例化多少次，都用第一次创建的那个对象，内存地址一样
class Singleton(object):
  instance = None
  def __new__(cls, *args, **kwargs):
    if not cls.instance:
    	cls.instance = object.__new__(cls)
    return cls.instance
 
obj1 = Singleton()   # 内存地址一致
obj2 = Singleton()
```

#### 1.2 标准

```python
# 需要加锁，多线程，并发
```

```python
class FileHelper(object):
  instance = None
	def __init__(self, path):
    self.file_object = open(path, mode='r', encoding='utf-8')
  
  def __new__(cls, *args, **kwargs):
    if not cls.instance:
      cls.instance = object.__new__(cls)
    return cls.instance
  
obj1 = FileHelper('x')   # 内存地址一致
obj2 = FileHelper('x')
```

### 2. 模块导入

```python
# 导入模块，只是保留模块内存
# 思考角度：函数名不能重复、内存溢出
from jd import n1

# 多次导入，模块只会加载一次，即使模块中包含其他模块
import jd
import jd
print(456)
```

```python
# 多次导入，模块只会加载一次，即使模块中包含其他模块
import importlib
import jd
importlib.reload(jd)  # 手动加载，会覆盖第一次导入
print(456)
```

- 通过模块导入特性，也可以实现单例模式

```python
# jd.py
class Foo(object):
  pass
obj = Foo()
```

```python
# app.py
import jd   # 加载jd.py ,加载最后会是例化一个Foo对象并赋值给obj
print(jd.obj)
```























